Fisher Linear Discriminant Analysis Cheng Li, Bingyu Wang August 31, 2014 What's LDA 1 Fisher Linear Discriminant Analysis (also called Linear Discriminant Analy- sis(LDA)) are methods used in statistics, pattern recognition and machine learn- ing to find a linear combination of features which characterizes or separates two or more classes of objects or events. The resulting combination may be used as a linear classifier, or, more commonly, for dimensionality reduction before later classification. LDA is closely related to PCA, for both of them are based on linear, i.e. matrix multiplication, transformations. For the case of PCA, the transformation is based on minimizing mean square error between original data vectors and data vectors that can be estimated fro the reduced dimensionality data vectors. And the PCA does not take into account any difference in class. But for the case of LDA, the transformation is based on maximizing a ratio of "between-class variance" to "within-class variance" with the goal of reducing data variation in the same class and increasing the separation between classes. Let's see an example of LDA as below(Figure 1): 6 Figure 1: LDA examples The left plot shows samples from two classes (depicted in red and blue) along with the histograms resulting from projection onto the line joining the class means. Note that there is considerable class overlap in the projected space. The right plot shows the corresponding projection based on the Fisher linear discriminant, showing the greatly improved class separation. So our job is seeking to obtain a scalar y by projecting the samples X onto a line: <math>u = \theta^T X</math> 1

Then try to find the <math>\theta^*</math> to maximize the ratio of "between-class variance" to "within-class variance". Next, we will introduce how to use mathematic way to present this problem. <math>\mathbf{2}</math> Theory and Model To figure out the LDA, first we need know how to translate "between-class variance" and "within-class variance" to mathematic language. Then we try to maximize the ratio between these two. To simplify the problem, we start with two classes problem. 2.1 Two Classes Problem 2.1.1 Head the Problem Assume we have a set of D-dimensional samples <math>X = \{x^{(1)}, x^{(2)}, ... x^{(m)}\}, N_1</math> of which belong to class <math>C_1</math>, and <math>N_2</math> of which belong to class <math>C_2</math>. We also assume the mean vector of two classes in X-space: <math>u_k = \frac{1}{N_k} \sum_{i \in C} x^{(i)}</math> where <math>k = 1, 2</math>. and in y-space: <math>\hat{u}_k = \frac{1}{N_k} \sum_{i \in C} y^{(i)} = \frac{1}{N_k} \sum_{i \in C} \theta^T x^{(i)} = \theta^T u_k \text{ where } k = 1, 2.</math> One way to define a measure of separation between two classes is to choose the distance between the projected means, which is in y-space, so the <b>between-</b> class variance is: <math display="block">\hat{u}_2 - \hat{u}_1 = \theta^T (u_2 - u_1)</math> Also, we can define the within-class variance for each class <math>C_k</math> is: <math>\hat{s}_k^2 = \sum_{i \in C} (y^{(i)} - \hat{u}_k)^2</math> where <math>k = 1, 2</math>. Then, we get the between-class variance and within-class variance, we can define our objective function <math>J(\theta)</math> as: <math display="block">J(\theta) = \frac{(\hat{u}_2 - \hat{u}_1)^2}{\hat{s}_1^2 + \hat{s}_2^2}</math> In fact, if maximizing the objective function <math>J</math>, we are looking for a projection where examples from the class are projected very close to each other and at the same time, the projected means are as farther apart as possible. 2.1.2 Transform the Problem To find the optimum <math>\theta^*</math>, we must express <math>J(\theta)</math> as a function of <math>\theta</math>. Before the optimum, we need introduce <b>scatter</b> instead of variance. We define some measures of the scatter as following: 2

• The scatter in feature space-x: <math>S_k = \sum_{i \in C_k} (x^{(i)} - u_k)(x^{(i)} - u_k)^T</math> • Within-class scatter matrix: <math>S_W = S_1 + S_2</math> • Between-class scather matrix: <math>S_B = (u_2 - u_1)(u_2 - u_1)^T</math> Let's see <math>J(\theta)</math> again: <math display="block">J(\theta) = \frac{(\hat{u}_2 - \hat{u}_1)^2}{\hat{s}_1^2 + \hat{s}_2^2}</math> The scatter of the projection <math>y</math> can then be expressed as a function of the scatter matrix in feature space <math>x</math>: <math display="block">\hat{s}_k^2 = \sum_{i \in C_k} (y^{(i)} - \hat{u}_k)^2</math> <math display="block">=\sum_{i\in\mathcal{I}}(\theta^Tx^{(i)}-\theta^Tu_k)^2</math> <math display="block">= \sum_{i \in C} \theta^{T} (x^{(i)} - u_k) (x^{(i)} - u_k)^{T} \theta</math> <math>= \theta^T S_k \theta</math> So we can get: <math display="block">\hat{s}_{1}^{2} + \hat{s}_{2}^{2} = \theta^{T} S_{1} \theta + \theta^{T} S_{2} \theta</math> <math>= \theta^T S_W \theta</math> Similarly, the difference between the projected means can be expressed in terms of the means in the original feature space: <math>(\hat{u}_2 - \hat{u}_1)^2 = (\theta^T u_2 - \theta^T u_1)^2</math> <math>=\theta^T(u_2-u_1)(u_2-u_1)^T\theta</math> <math>=\theta^T S_B \theta</math> We can finally express the Fisher criterion in terms of <math>S_W</math> and <math>S_B</math> as: <math display="block">J(\theta) = \frac{\theta^T S_B \theta}{\theta^T S_W \theta}</math> Next, we will maximize this objective function. 2.1.3 Solve the Problem The easiest way to maximize the object function <math>J</math> is to derive it and set it to zero. <math display="block">\frac{\partial J(\theta)}{\partial \theta} = \frac{\partial}{\partial \theta} \left( \frac{\theta^T S_B \theta}{\theta^T S_W \theta} \right)</math> <math display="block">=(\theta^TS_W\theta)\frac{\partial(\theta^TS_B\theta)}{\partial\theta}-(\theta^TS_B\theta)\frac{\partial(\theta^TS_W\theta)}{\partial\theta}=0</math> <math>\implies = (\theta^T S_W \theta) 2S_B \theta - (\theta^T S_B \theta) 2S_W \theta = 0</math> 3

Divided by <math>\theta^T S_W \theta</math>: <math display="block">\implies (\frac{\theta^T S_W \theta}{\theta^T S_W \theta}) S_B \theta - (\frac{\theta^T S_B \theta}{\theta^T S_W \theta}) S_W \theta = 0</math> <math>\implies S_B \theta - J S_W \theta = 0</math> <math>\implies S_W^{-1} S_B \theta - J \theta = 0</math> <math>\implies J\theta = S_W^{-1} S_B \theta</math> <math>\implies J\theta = S_W^{-1}(u_2 - u_1)(u_2 - u_1)^T\theta</math> <math display="block">\implies J\theta = S_W^{-1}(u_2 - u_1)(\underbrace{(u_2 - u_1)^T \theta}_{c \in \mathbb{R}})</math> <math>\implies J\theta = cS_W^{-1}(u_2 - u_1)</math> <math>\implies \theta = \frac{c}{I} S_W^{-1} (u_2 - u_1)</math> For now, the problem has been solved and we just want to get the direction of the <math>\theta</math>, which is the optimum <math>\theta^*</math>: <math display="block">\theta^* \propto S_W^{-1}(u_2 - u_1)</math> This is known as Fisher's linear discriminant (1936), although it is not a dis- criminant but rather a specific choice of direction for the projection of the data down to one dimension, which is <math>y = \theta^{*T} X</math>. 2.2 MultiClasses Problem Based on two classes problem, we can see that the fisher's LDA generalizes grace- fully for multiple classes problem. Assume we still have a set of D-dimensional samples <math>X = \{x^{(1)}, x^{(2)}, ..., x^{(m)}\}</math>, and there are totally C classes. Instead of one projection <math>y</math>, mentioned above, we now will seek <math>(C-1)</math> projections <math>[y_1, y_2, \dots, y_{C-1}]</math> by means of <math>(C-1)</math> projection vectors <math>\theta_i</math> arranged by columns into a projection matrix <math>\Theta = [\theta_1 | \theta_2 | \dots | \theta_{C-1}]</math>, where: <math>y_i = \theta_i^T X \implies y = \Theta^T X</math> 2.2.1 Derivation First we will use the scatters in space-x as following: • Within-class scatter matrix: <math>S_W = \sum_{i=1}^{\infty} S_i</math> where <math>S_i = \sum_{i \in C} (x^{(i)-u_i})(x^{(i)} - u_i)^T</math> and <math>u_i = \frac{1}{N_i} \sum_{i \in C} x^{(i)}</math> • Between-class scatter matrix: <math>S_B = \sum_{i=1}^{C} N_i (u_i - u)(u_i - u)^T</math> where <math>u = \frac{1}{m} \sum_{i=1}^{m} x^{(i)} = \frac{1}{m} \sum_{i=1}^{C} N_i u_i</math> • Total scatter matrix: <math>S_T = S_B + S_W</math> 4

s S<sub>W2</sub> X, Figure 2: LDA Multi-Class examples Before moving on, let us see a picture for the multi-class example in Figure 2: Similarly, we define the mean vector and scatter matrices for the projected samples as: • <math>\hat{u}_i = \frac{1}{N_i} \sum_{i \in C_i} y^{(i)}</math> • <math>\hat{u} = \frac{1}{N} \sum_{i=1}^{m} y^{(i)}</math> • <math>\hat{S}_W = \sum_{i=1}^C \sum_{y \in C_i} (y - \hat{u}_i)(y - \hat{u}_i)^T</math> • <math>\hat{S}_B = \sum_{i=1}^C N_i (\hat{u}_i - \hat{u}) (\hat{u}_i - \hat{u})^T</math> From our derivation for the two-class problem, we can get: <math display="block">\hat{S}_W = \Theta^T S_W \Theta</math> (1) <math display="block">\hat{S}_B = \Theta^T S_B \Theta</math> (2) Recall that we are looking for a projection that maximizes the ratio of between- class to within-class scatter. Since the projection is no longer a scalar (it has <math>C-1</math> dimensions), we use the determinant of the scatter matrices to obtain a scalar objective function: <math display="block">J(W) = \frac{|\hat{S}_B|}{|\hat{S}_W|} = \frac{|\Theta^T S_B \Theta|}{|\Theta^T S_W \Theta|}</math> And now, our job is to seek the projection matrix <math>\Theta^*</math> that maximize this ratio. We will not give the derivation process. But we know that the optimal projection matrix <math>\Theta^*</math> is the one whose columns are the eigenvectors corresponding to the 5

largest eigenvalues of the following generalized eigenvalue problem: <math display="block">\Theta^* = [\theta_1^* | \theta_2^* | \dots | \theta_{C-1}^*]</math> <math display="block">= \operatorname{argmax} \frac{|\Theta^T S_B \Theta|}{|\Theta^T S_W \Theta|}</math> <math>\implies (S_B - \lambda_i S_W) \theta_i^* = 0</math> Thus, if <math>S_W</math> is a non-singular matrix, and can be inverted, then the Fisher's criterion is maximized when the projection matrix <math>\Theta^*</math> is composed of the eigen- vectors of: <math>S_W^{-1}S_B</math> Noticed that, there will be at most <math>C-1</math> eigenvectors with non-zero real cor- responding eigenvalues <math>\lambda_i</math>. This is because <math>S_B</math> is of rank <math>(C-1)</math> or less. So we can see that LDA can represent a massive reduction in the dimensionality of the problem. In face recognition for example there may be several thousand variables, but only a few hundred classes. 3 References 1. L10: Linear discriminants analysis [http://research.cs.tamu.edu/prism/ lectures/pr/pr_l10.pdf 2. LDA-linear discriminant analysis [http://webdancer.is-programmer.com/ posts/37867.html 3. Lecture 16: Linear Discriminant Analysis [http://www.doc.ic.ac.uk/ ~dfg/ProbabilisticInference/IDAPILecture16.pdf] 4. Nonlinear Dimensionality Reduction Methods for Use with Automatic Speech Recognition By Stephen A. Zahorian and Hongbing Hu 6